#!/usr/bin/env ruby
# coding: utf-8

$:.unshift File.join(File.dirname(__FILE__), '..', 'lib')

require 'tres'
require 'colorize'

ACTIONS = {
  :server   => %w(server),
  :new_at   => %w(new),
  :screen   => %w(screen)
}

def bail! reason
  puts reason
  exit -2
end

def figure_what_to_do!
  help_and_exit! if ARGV.empty?
  if ACTIONS.values.flatten.include? ARGV.first
    action = ACTIONS.select { |action, args| args.include? ARGV.first }.flatten.first
    send action, *ARGV[1..(ARGV.length - 1)]
  else
    help_and_exit!
  end
end

def help_and_exit!
  STDERR.puts <<-HELP

Tres 
  Usage:
    tres new <directory>
  Example:
    tres new myapp
  Other commands:
    help        shows this menu
    version     shows the current version of Tres you have installed
    
  HELP
  exit -1
end

def new_at dir
  app = nil
  Tres.say_progress "Creating Tres app on #{dir.dup.colorize(:yellow)}" do
    app = Tres::App.new dir
  end
  Tres.say_progress "Compiling boilerplate templates" do
    app.template_compiler.compile_all
  end
  Tres.say "All done!"
end

def server
  Tres.say "Starting server"
  app = Tres::App.open Dir.pwd
  Rack::Handler.default.run Tres::Server.new(app).to_rack_app, :Port => 4567
end

def screen name
  app = Tres::App.open Dir.pwd, :deaf => true
  Tres.say_progress "Creating template #{name.downcase.colorize(:yellow)}" do
    app.template_compiler.new_template name.downcase
  end
  Tres.say_progress "Creating script #{name.downcase.colorize(:yellow)}" do
    script = Tilt.new(Tres.templates_dir/'screen_script.coffee.erb')
    script = script.render OpenStruct.new(:name => name)
    app.asset_packager.new_script "screens/#{name.downcase}", script
  end
end

figure_what_to_do!